<!DOCTYPE>
<html>
<head>

<style type="text/css">
body {
	font-family: ;
}

code.inlinecode {
	display: inline;
}
code.blockcode {
	display: block;
}
</style>

<title>Internet worm, technical details and aftermath</title>

</head>
<body>

<h1>Internet worm, technical details and aftermath</h1>

<p class="">
The <strong>Internet worm</strong>, also known as <em>Morris worm</em>, was the first program to run and propagate by itself through the internet, taking advantages of bugs and security holes to infect SUN3 and <abbr title="Berkeley Software Distribution">BSD</abbr>-derived UNIX systems.
</p>

<h2>Historical perspective</h2>

<h2>Technical details</h2>
<h3>Major security issues</h3>
<p>
<em>Morris worm</em> spread using many approaches to infect new systems. In order to understand the success of this worm, let's first take a look at the main security flaws and weaknesses it exploited.
</p>

<h4>Sendmail</h4>
<p>
The sendmail program is a mailer shipped with BSD systems that supports many transfer protocols such as <abbr title="Simple Mail Transfer Protocol">SMTP</abbr>. It is mainly used as a daemon process which permanently listens to the #25 TCP port, in order to retrieve incoming mails by handling requests from remote mailers.
</p>
<p>
Sendmail has a DEBUG flag &ndash; activated by default in the compilation process at the time &ndash; which facilitates maintenance and configuration for system administrators. The dangerous part of the feature is that it allowed someone to send a message to a process rather than a user. Used accurately, with the proper recipient, the worm was able to execute arbitrary code.
</p>
<p>
The underlying issue raised by this attack is the lack of knowledge and skill of most of administrators upon widely-spread tools like sendmail. It is possible to prevent this flaw only by editing configuration files. But it also points out the complexity of configuring such very complex services. 
</p>

<h4>fingerd daemon</h4>
<p>
<stong>fingerd</strong> is a simplistic daemon to send &ldquo;human oriented&rdquo; and textual informations. This program handles remote requests on TCP port #79 to transmit user informations over the network such as full name, login name or email.
</p>
<p>
The finger program uses the <code class="inlinecode">gets(char *)</code> function from the Standard C Library to receive the input string argument. However, this routine doesn't check for bounds by itself and lets the user overwrite the buffer if no additional control is made. The Morris worm takes advantage of this lack by passing a argument which overwrite the 512 character buffer of fingerd and writes into the system stack, changing the return address pointed by the <code class="inlinecode">main</code> function, to launch a remote shell.
</p>
<p>
This stack-overflow attack didn't succeed on SUN systems, since the fingerd version should have been compromised without the same exact pattern. The worm should have been extended to work on is SUN version.
</p>

<h4>Weak passwords</h4>
<p>
Another way for the worm to connect to new hosts was to try to launch a remote shell with <code style="inlinecode">rsh</code> using the username and password of users of the infected machine. In order to find this password 
</p>

<h3>The worm map</h3>

<h2>Discussion, aftermath, what have we learn, conclusion...</h2>

<h2>References</h2>
<ul>
<li><strong>The What, Why, and How of the 1988 Internet Worm</strong> by Tom Darby [http://www.snowplow.org/tom/worm/worm.html]</li>
<li><strong>A REPORT ON THE INTERNET WORM</strong> by Bob Page [http://www.ee.ryerson.ca/~elf/hack/iworm.html]</li>
<li><strong>The Internet Worm Program: An Analysis</strong> by Eugene H. Spafford</li>
<li><strong>stackoverflow.com</strong> question 1799670</li>
</ul>
</body>
</html>