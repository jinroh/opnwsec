<!DOCTYPE>
<html>
<head>

<style type="text/css">
body {
	font-family: ;
}

code.blockcode {
	display: block;
}
</style>

<title>Internet worm, technical details and aftermath</title>

</head>
<body>

<h1>Internet worm, technical details and aftermath</h1>

<p class="">
The <strong>Internet worm</strong>, also known as <em>Morris worm</em>, was the first program to run and propagate by itself through the internet, taking advantages of bugs and security holes to infect SUN3 and <abbr title="Berkeley Software Distribution">BSD</abbr>-derived UNIX systems.
</p>

<h2>Historical perspective</h2>

<h2>Technical details</h2>
<h3>Major security issues</h3>
<p>
<em>Morris worm</em> spread using many approaches to infect new systems. In order to understand the success of this worm, let's first take a look at the main security flaws and weaknesses it exploited.
</p>

<h4>Sendmail</h4>
<p>
The sendmail program is a mailer shipped with BSD systems that supports many transfer protocols such as <abbr title="Simple Mail Transfer Protocol">SMTP</abbr>. It is mainly used as a daemon process which permanently listens to the #25 TCP port, in order to retrieve incoming mails by handling requests from remote mailers.
</p>
<p>
Sendmail has a DEBUG flag &ndash; activated by default in the compilation process at the time &ndash; which facilitates maintenance and configuration for system administrators. The dangerous part of the feature is that it allowed someone to send a message to a process rather than a user. Used accurately, with the proper recipient, the worm was able to execute arbitrary code.
</p>
<p>
The underlying issue raised by this attack is the lack of knowledge and skill of most of administrators upon widely-spread tools like sendmail. It is possible to prevent this flaw only by editing configuration files. But it also points out the complexity of configuring such very complex services. 
</p>

<h4>fingerd daemon</h4>
<p>
<stong>fingerd</strong> is a simplistic daemon to send &ldquo;human oriented&rdquo; and textual informations. This program handles remote requests on TCP port #79 to transmit user informations over the network such as full name, login name or email.
</p>
<p>
The finger program uses the <code>gets(char *)</code> function from the Standard C Library to receive the input string argument. However, this routine doesn't check for bounds by itself and lets the user overwrite the buffer if no additional control is made. The Morris worm takes advantage of this lack by passing a argument which overwrite the 512 character buffer of fingerd and writes into the system stack, changing the return address pointed by the <code>main</code> function, to launch a remote shell.
</p>
<p>
This stack-overflow attack didn't succeed on SUN systems, since the fingerd version should have been compromised without the same exact pattern. The worm should have been extended to work on is SUN version.
</p>

<h4>Weak passwords</h4>
<p>
Another way for the worm to connect to new hosts was to try to launch a remote shell with <code>rsh</code> using the username and password of users on the infected machine. The weak point used by the worm here is that <code>/etc/passwd</code> was publicly readable. Therefore, it was able to &ldquo;brute-force&rdquo; salted passwords by matching strings, and not through the system input. The mode of the <code>/etc/passwd</code> file is one the main security hole the worm takes advantage of.
</p>
<p>
Additional question this worm brings up is the weakness of users' passwords. According to a study<sup><a href="#study">[4]</a></sup>, 30% of the passwords were guessed by trying passwords with informations from the user like it's username, first name or full name.
</p>

<h3>The worm map</h3>
<p>
It's possible to understand quite easily the process of the worm by taking a high level overview. Morris worm's only objective is to duplicate on other machines by using the flaws and weaknesses already presented. The worm is also deliberately designed to make it difficult to stop or captured.
</p>
<p>
Let's take a look, step by step, to the architecture of the Morris worm. To begin the tour, we will start when the worm files have been compiled and launched on a target. In other words, the first instruction of the <code>main</code> function is our starting point
</p>

<h4>Initialization</h4>
<p>
First the worm initiates the objects it needs and try to hide its presence :
<ul>
<li>changes its process name to <code>sh</code>, which a very common duplicated process for shells</li>
<li>set the size of its core dump to zero to prevent investigation of its code</li>
<li>destroy its binary version from the disk</li>
<li>loads the objects put in parameters from files in memory (into the <code>objects</code> global variable), encrypts them and finally deletes them from disk</li>
<li>changes of process group and kills his parent process which created this version of the worm</li>
</ul>
If the initialization process of the objects fails, the worm stops. The objects the worm stores will be used later to infest other system, they are essentials and can be source code or compiled objects.
</p>

<h4>Spreading</h4>
<p>
Now the main goal of the worm is in the first place to find other hosts on the network and then to find a way to open a remote shell on these hosts to execute code and infest the system.
</p>
<p>
Before trying to find hosts, the worm tries to find if it's already launched on the machine by sending &ldquo;magical&rdquo; numbers using its own protocol on ports of localhost. If it finds a process which respond with the good number, it would stop. Except for 1 out of 7 worms, randomly chosen, which would continue anyway. This technique prevent from fake worm processes that would stop the spawning of new worms.
</p>
<p>
The worm instantiates global arrays which stores hosts and gateways of the network. It uses them as databases of potential victims, marking them as infected or immune whether it already infected them or failed its attack.
</p>
<p>
To fill these variables, the worm uses <code>ioctl</code> calls for interfaces, <code>netstat</code> to get a list of gateways or even generates random ip addresses on a subnet using a particular netmask.
</p>
<p>
After having retrieved informations on the network and hosts, checking if hosts were reachable by initiating a <code>telnet</code> connection, the worm starts infecting some of those hosts, chosen randomly.
</p>

<h4>Infect hosts</h4>

<h4>Cracksome</h4>
<h2>Discussion, aftermath, what have we learn, conclusion...</h2>

<h2>References</h2>
<ul>
<li><strong>The What, Why, and How of the 1988 Internet Worm</strong> by Tom Darby [http://www.snowplow.org/tom/worm/worm.html]</li>
<li><strong>A report on the internet worm</strong> by Bob Page [http://www.ee.ryerson.ca/~elf/hack/iworm.html]</li>
<li><strong>The Internet Worm Program: An Analysis</strong> by Eugene H. Spafford</li>
<li id="study"><strong>UNIX Operating System Security</strong> by Grampp, Fred. T. and Robert H. Morris</li>
<li><strong>stackoverflow.com</strong> question 1799670</li>
</ul>
</body>
</html>